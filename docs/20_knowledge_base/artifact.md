---
label: Artifact
layout: default
order: 800
---

# Artifact

An artifact is the result of a Transformation for a specific context and/or object, it can have different format either in plain text or JSON.

- For a network device, an artifact can be used to track the configuration generated from a Jinja template (RFile)
- For a Security Device, an artifact can be the list of rules in JSON in the format of your choice generated by a Python Transformation

An artifact can also represent the configuration of a DNS server or the configuration of a specific VIP.

While it's always possible to generate Transformations on demand via the API, having an Artifact provide some additional features:
- Caching : Generated Artifact are stored in the internal file storage. For resource intensive Transformation, it will significantly reduce the load of the system if we don't need to regenerate the artifact all the times
- Traceability : Past values of an artifact remains available. In a future release it will be possible to compare the value of an artifact over time.
- Review : Artifact are automatically part of the Proposed Change review process

While the content of an artifact can change, it's identifier will remain the same over time.

## High level design

Artifacts are defined by grouping a Transformation with a Group of targets in an Artifact Definition.

An Artifact Definition centralize all the information required to generate an artifact
- Group of targets
- Transformation
- Format of the output
- Information to extract from each target that must be passed to the transformation.

![](../media/artifact.excalidraw.svg)


## Artifact Definiton

Artifact Definition can be created via the Frontend, via GRaphQL or via a Git Repository

## Artifact

Artifact can be accessed via the frontend and via GraphQL but they shouldn't be manually created, all artifacts should be generated and managed by Infrahub.

### Import from a Git Repository


## Screenshots

TODO Add screenshot here

## Storage

Generated Artifact are stored in the internal file storage with a unique Storage ID. The internal file storage is designed to support multiple backend